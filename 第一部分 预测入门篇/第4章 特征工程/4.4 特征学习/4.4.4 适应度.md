```python
def get_adjust(std_error, y, indiv_data, handle):
    """计算适应度，通过外部定义的handle来处理，同时适用于分类和回归问题"""
    X = indiv_data
    cur_error = handle(X,y)
    return std_error - cur_error if std_error > cur_error else 0
```

```python
from sklearn import tree
from sklearn import linear_model 

def evaluation_classify(X,y):
    """建立分类问题的评估方法"""
    clf = tree.DecisionTreeClassifier(random_state=0)
    errors = []
    for i in range(X.shape[0]):
        index = [e for e in range(X.shape[0])]
        index.remove(i)
        X_train = X.iloc[index,:]
        X_test = X.iloc[[i],:]
        y_train = y[index]
        y_test = y[i]
        clf.fit(X_train, y_train)
        errors.extend(clf.predict(X_test) != y_test)
    return np.sum(errors)/len(errors)

def evaluation_regression(X,y):
    """建立回归问题的评估方法"""
    reg = linear_model.LinearRegression()
    errors = 0
    for i in range(X.shape[0]):
        index = [e for e in range(X.shape[0])]
        index.remove(i)
        X_train = X.iloc[index,:]
        X_test = X.iloc[[i],:]
        y_train = y[index]
        y_test = y[i]
        reg.fit(X_train, y_train)
        errors = errors + (y_test - reg.predict(X_test)[0])**2
    return errors/np.sum(y)
```
