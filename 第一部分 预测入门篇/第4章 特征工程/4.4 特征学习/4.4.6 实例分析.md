```python
import pandas as pd
import numpy as np
# 读入基础数据
cemht = pd.read_csv("cemht.csv")
X = cemht.drop(columns=['No','Y'])
y = cemht.Y
# 对 X1~X4 进行标准化处理
X = X.apply(lambda x: (x - np.mean(x))/np.std(x),axis=1)
X.head()
# 	       X1	      X2	      X3	      X4
#0	-0.812132	0.057192	-0.857886	1.612825
#1	-1.234525	0.252215	-0.491155	1.473466
#2	-0.666283	1.685303	-0.823055	-0.195965
#3	-0.836854	0.426322	-1.026330	1.436862
#4	-0.910705	1.431108	-0.962745	0.442343
```

```python
std_error = evaluation_regression(X,y)
std_error
# 206.9160090080068
```

```python
# 产生初始种群，假设种群规模为100
popSize = 100
# 设置特征长度为3
needgs = 3
# 交叉重组触发概率
cross_prob = 0.85
# 突变概率
mutate_prob = 0.1
# 原始特征序号
featureIdx = [1,2,3,4]
# 产生初始种群
individuals = gen_individuals(popSize,needgs,X,featureIdx)
adjusts = []
for df in individuals['df']:
    adjusts.append(get_adjust(std_error, y, df, evaluation_regression))

adjusts
# array([  0.        ,   0.        ,   0.        ,   0.        ,
#          0.        ,   0.        ,   0.        ,   0.        ,
#          0.        ,   0.        , 102.31682884,   0.        ,
# ......
#          0.        ,   0.        ,   0.        ,   0.        ])
```

```python
import copy
max_epochs = 10000
for k in range(max_epochs):
    # 0.备份父代个体
    pre_indivs = copy.deepcopy(individuals)
    pre_adjusts = adjusts.copy()
    # 1.交叉
    inter_cross(individuals['df'], individuals['gene'], cross_prob)
    # 2.变异
    mutate(individuals['df'], individuals['gene'], mutate_prob, X, featureIdx)
    # 3.计算适应度
    adjusts = []
    for df in individuals['df']:
        adjusts.append(get_adjust(std_error, y, df, evaluation_regression))

    # 4.合并，并按adjusts降序排列，取前0.4*popSize个个体进行返回，对剩余的个体随机选取0.6*popSize个返回
    pre_gene_keys = [''.join(e) for e in pre_indivs['gene']]
    gene_keys = [''.join(e) for e in individuals['gene']]
    for i in range(len(pre_gene_keys)):
        key = pre_gene_keys[i]
        if key not in gene_keys:
            individuals['df'].append(pre_indivs['df'][i])
            individuals['gene'].append(pre_indivs['gene'][i])
            adjusts.append(pre_adjusts[i])

    split_val = pd.Series(adjusts).quantile(q=0.6)
    index = list(range(len(adjusts)))
    need_delete_count = len(adjusts) - popSize
    random.shuffle(index)
    indices  = []
    for i in index:
        if need_delete_count > 0:
            if adjusts[i] <= split_val:
                indices.append(i)
                need_delete_count = need_delete_count -1
        else:
            break

    individuals['df'] = [i for j, i in enumerate(individuals['df']) if j not in indices]
    individuals['gene'] = [i for j, i in enumerate(individuals['gene']) if j not in indices]
    adjusts = [i for j, i in enumerate(adjusts) if j not in indices]
    alpha = np.max(adjusts)/np.mean(adjusts)
    if k%100 == 99 or k==0:
        print("第 ",k+1," 次迭代，最大适应度为 ",np.max(adjusts)," alpha : ",alpha)
    if np.mean(adjusts) > 0 and alpha < 1.001:
        print("进化终止，算法已收敛！ 共进化 ",k," 代！")
        break
```

```python
#提取适应度最高的一个个体，获取其特征
loc = np.argmax(adjusts)
new_x = individuals['df'][loc]
new_x.head()
#   	  g1	      g2	      g3
#0	0.000000	0.435073	0.769591
#1	0.000000	0.468825	0.812477
#2	13.522956	-140.594366	0.298302
#3	0.000000	0.799328	0.692120
#4	12.635694	1.374167	0.431636

counter = 1
titles=['特征-g1','特征-g2','特征-g3']
plt.figure(figsize=(10,20))
for e in individuals['gene'][loc]:
    plt.subplot(3,1,counter)
    plot_tree(e, title=titles[counter - 1],node_size= 1000,font_size=13)
    counter = counter + 1
plt.show()
```
