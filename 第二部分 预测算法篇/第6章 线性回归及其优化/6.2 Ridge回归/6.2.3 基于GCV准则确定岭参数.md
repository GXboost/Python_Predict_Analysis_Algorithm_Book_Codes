```python
def get_best_k(X,y,kmax=1,qnum=10,intercept=True):
    """
    根据GCV方法，获得最佳岭参数k 
    X : 自变量的数据矩阵
    y : 响应变量向量或矩阵
    kmax : 岭参数的最大值
    qnum : 将0~kmax的区间分成qnum等分
    intercept : 是否计算戴距
    """
    n = X.shape[0]
    if intercept:
        X = np.c_[X,[1]*n]
    
    gcv_list = []
    kvalues = np.linspace(0,kmax,qnum+1)
    for k in kvalues:
        mk = np.matmul(np.matmul(X,np.linalg.inv(np.matmul(X.T,X)+k*np.identity(X.shape[1]))),X.T)
        yk = np.matmul(mk,y)
        trmk = np.trace(mk)
        gcv = np.sum((y - yk)**2)/(n*(1-trmk/n)**2)
        gcv_list.append(gcv)
        
    return kvalues[np.argmin(gcv_list)], np.min(gcv_list)

import pandas as pd
iris=pd.read_csv("iris.csv")
x = iris.iloc[:,[0,1,2]].values
y = iris.iloc[:,3].values
get_best_k(x, y, qnum = 100)
# (0.59, 0.037738709088905156)
```