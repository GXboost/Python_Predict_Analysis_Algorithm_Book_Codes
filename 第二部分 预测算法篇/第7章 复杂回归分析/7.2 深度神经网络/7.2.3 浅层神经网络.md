```python
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split

# 准备基础数据
iris = pd.read_csv("iris.csv")
x,y = iris.drop(columns=['Species','Petal.Width']),iris['Petal.Width']

# 标准化处理
x = x.apply(lambda v:(v-np.mean(v))/np.std(v))
x = np.c_[[1]*x.shape[0],x]
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.33, random_state=1)

# 设定学习效率 alpha
alpha = 0.01

# 评估隐含层神经元个数
m = int(np.round(np.sqrt(0.43*1*4+0.12+2.54*4+0.77+0.35)+0.51,0))

# 初始化输入向量的权重矩阵
wInput = np.random.uniform(-1,1,(m,4))

# 初始化隐含层到输出的权重向量
wHide = np.random.uniform(-1,1,m)
epsilon = 1e-3
errorList = []
```

```python
# 进入迭代
for p in range(1000):
    error = 0
    for i in range(x_train.shape[0]):
        # 正向传播过程
        xInput = x_train[i,:]
        d = np.matmul(wInput,xInput)
        z = (np.exp(d)-np.exp(-d))/(np.exp(d)+np.exp(-d))
        o = np.matmul(wHide,z)
        e = o - y_train.values[i]
        error = error + e**2
        
        # 若 e>epsilon，则进入反向传播过程
        if np.abs(e) > epsilon:
            wHide = wHide - alpha*z*e
            a = (4*np.exp(2*d)/((np.exp(2*d)+1)**2))*wHide*alpha*e
            wInput = wInput - [x*xInput for x in a]
            
    errorList.append(error)
    print("iter:",p,"error:",error)
    # 当连续两次残差平方和的差小于epsilon时，退出循环
    if len(errorList) > 2 and errorList[-2] - errorList[-1] < epsilon:
        break
        
# iter: 0 error: 155.54395018394294
# iter: 1 error: 56.16645418105049
# iter: 2 error: 28.788174184286994
# ......
# iter: 141 error: 2.8748747912336405
# iter: 142 error: 2.873880717019784
```

```python
error
# 2.873880717019784

wInput
# array([[ 1.42771077, -0.20451346, -0.11610576,  0.54878999],
#        [ 0.40080947,  0.67893308,  0.15667116, -0.56050505],
#        [ 0.15342243, -0.01495382,  0.19293603, -0.88798248],
#        [-0.52516692,  0.81847855, -0.46910003, -0.34153195]])

wHide
# array([ 0.91786267,  0.521612  , -1.32963221, -0.67729756])
```

```python
y_pred = []
for i in range(x_test.shape[0]):
    # 正向传播过程
    xInput = x_test[i,:]
    d = np.matmul(wInput,xInput)
    z = (np.exp(d)-np.exp(-d))/(np.exp(d)+np.exp(-d))
    o = np.matmul(wHide,z)
    y_pred.append(o)
    
np.sum((y_test.values - y_pred)**2)
# 2.125832275861781
```